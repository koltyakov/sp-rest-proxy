// Generated by typings
// Source: node_modules/sp-request/lib/src/core/utils/Cache.d.ts
declare module '~sp-request/lib/src/core/utils/Cache' {
export class Cache {
    private _cache;
    set(key: string, data: any, expiration?: number | Date): void;
    get<T>(key: string): T;
    remove(key: string): void;
    clear(): void;
    private getHashKey(key);
}
}
declare module 'sp-request/lib/src/core/utils/Cache' {
export * from '~sp-request/lib/src/core/utils/Cache';
}

// Generated by typings
// Source: node_modules/sp-request/lib/src/core/SPRequest.d.ts
declare module '~sp-request/lib/src/core/SPRequest' {
import { IUserCredentials } from '~sp-request/lib/src/core/auth/IUserCredentials';
import { IEnvironment } from '~sp-request/lib/src/core/auth/IEnvironment';
import { ISPRequest } from '~sp-request/lib/src/core/ISPRequest';
import { Cache } from '~sp-request/lib/src/core/utils/Cache';
export var requestDigestCache: Cache;
export function create(credentials: IUserCredentials, environment?: IEnvironment): ISPRequest;
}
declare module 'sp-request/lib/src/core/SPRequest' {
export * from '~sp-request/lib/src/core/SPRequest';
}

// Generated by typings
// Source: node_modules/sp-request/lib/src/core/auth/IEnvironment.d.ts
declare module '~sp-request/lib/src/core/auth/IEnvironment' {
export interface IEnvironment {
    domain?: string;
    workstation?: string;
}
}
declare module 'sp-request/lib/src/core/auth/IEnvironment' {
export * from '~sp-request/lib/src/core/auth/IEnvironment';
}

// Generated by typings
// Source: node_modules/sp-request/lib/src/core/auth/IUserCredentials.d.ts
declare module '~sp-request/lib/src/core/auth/IUserCredentials' {
export interface IUserCredentials {
    username: string;
    password: string;
}
}
declare module 'sp-request/lib/src/core/auth/IUserCredentials' {
export * from '~sp-request/lib/src/core/auth/IUserCredentials';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-form-data/edc32200ec6065d98bfaa7ff9cfd104e17c5d3e4/lib/form_data.d.ts
declare module '~sp-request~request~form-data' {
class FormData {
  static LINE_BREAK: string;
  static DEFAULT_CONTENT_TYPE: string;

  append (key: string, value: any, options?: string | FormData.Options): FormData;
  getHeaders <T> (userHeaders?: T): T & FormData.Headers;
  getCustomHeaders (contentType?: string): FormData.CustomHeaders;
  getBoundary (): string;
  getLengthSync (): number;
  getLength (cb: (error: Error, length?: number) => any): void;
  submit (params: string | Object, cb: (error: Error, response?: any) => any): any;
  pipe <T> (to: T): T;
}

module FormData {
  export interface Options {
    filename: string;
  }

  export interface Headers {
    'content-type': string;
  }

  export interface CustomHeaders extends Headers {
    'content-length': string;
  }
}

export = FormData;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-tough-cookie/3e37dc2e6d448130d2fa4be1026e195ffda2b398/lib/cookie.d.ts
declare module '~sp-request~request~tough-cookie' {
/**
 * Parse a cookie date string into a Date. Parses according to RFC6265
 * Section 5.1.1, not Date.parse().
 */
export function parseDate (date: string): Date;

/**
 * Format a Date into a RFC1123 string (the RFC6265-recommended format).
 */
export function formatDate (date: Date): string;

/**
 * Transforms a domain-name into a canonical domain-name. The canonical domain-name
 * is a trimmed, lowercased, stripped-of-leading-dot and optionally punycode-encoded
 * domain-name (Section 5.1.2 of RFC6265). For the most part, this function is
 * idempotent (can be run again on its output without ill effects).
 */
export function canonicalDomain (domain: string): string;

/**
 * Answers "does this real domain match the domain in a cookie?". The str is the
 * "current" domain-name and the domStr is the "cookie" domain-name. Matches
 * according to RFC6265 Section 5.1.3, but it helps to think of it as a "suffix match".
 *
 * The canonicalize parameter will run the other two paramters through canonicalDomain or not.
 */
export function domainMatch (str: string, domStr: string, canonicalize?: boolean): boolean;

/**
 * Given a current request/response path, gives the Path apropriate for storing in
 * a cookie. This is basically the "directory" of a "file" in the path, but is
 * specified by Section 5.1.4 of the RFC.
 *
 * The path parameter MUST be only the pathname part of a URI (i.e. excludes the hostname,
 * query, fragment, etc.). This is the .pathname property of node's uri.parse() output.
 */
export function defaultPath (path: string): string;

/**
 * Answers "does the request-path path-match a given cookie-path?" as
 * per RFC6265 Section 5.1.4. Returns a boolean.
 *
 * This is essentially a prefix-match where cookiePath is a prefix of reqPath.
 */
export function pathMatch (reqPath: string, cookiePath: string): boolean;

/**
 * alias for Cookie.parse(cookieString[, options])
 */
export function parse (cookieString: string, options?: CookieParseOptions): Cookie;

/**
 * alias for Cookie.fromJSON(string)
 */
export function fromJSON (json: string): Cookie;

/**
 * Returns the public suffix of this hostname. The public suffix is the shortest
 * domain-name upon which a cookie can be set. Returns null if the hostname cannot
 * have cookies set for it.
 *
 * For example: www.example.com and www.subdomain.example.com both have public suffix example.com.
 *
 * For further information, see http://publicsuffix.org/. This module derives its list from that site.
 */
export function getPublicSuffix (hostname: string): string;

/**
 * For use with .sort(), sorts a list of cookies into the recommended order
 * given in the RFC (Section 5.4 step 2). The sort algorithm is, in order of precedence:

 * - Longest .path
 * - oldest .creation (which has a 1ms precision, same as Date)
 * - lowest .creationIndex (to get beyond the 1ms precision)
 *
 * ```
 * var cookies = [ \/* unsorted array of Cookie objects *\/ ];
 * cookies = cookies.sort(cookieCompare);
 * ```
 *
 * Note: Since JavaScript's Date is limited to a 1ms precision, cookies within
 * the same milisecond are entirely possible. This is especially true when using
 * the now option to .setCookie(). The .creationIndex property is a per-process
 * global counter, assigned during construction with new Cookie(). This preserves
 * the spirit of the RFC sorting: older cookies go first. This works great for
 * MemoryCookieStore, since Set-Cookie headers are parsed in order, but may not
 * be so great for distributed systems. Sophisticated Stores may wish to set this
 * to some other logical clock such that if cookies A and B are created in the
 * same millisecond, but cookie A is created before cookie B, then
 * A.creationIndex < B.creationIndex. If you want to alter the global counter,
 * which you probably shouldn't do, it's stored in Cookie.cookiesCreated.
 */
export function cookieCompare (a: Cookie, b: Cookie): number;

/**
 * Generates a list of all possible domains that domainMatch() the parameter.
 * May be handy for implementing cookie stores.
 */
export function permuteDomain (domain: string): string[];

/**
 * Generates a list of all possible paths that pathMatch() the parameter.
 * May be handy for implementing cookie stores.
 */
export function permutePath (path: string): string[];

/**
 * Base class for CookieJar stores. Available as tough.Store.
 */
export class Store {
  // TODO(blakeembrey): Finish this.
  // https://github.com/SalesforceEng/tough-cookie#store
}

/**
 * A just-in-memory CookieJar synchronous store implementation, used by default.
 * Despite being a synchronous implementation, it's usable with both the
 * synchronous and asynchronous forms of the CookieJar API.
 */
export class MemoryCookieStore extends Store {}

/**
 * Exported via tough.Cookie.
 */
export class Cookie {
  /**
   * Parses a single Cookie or Set-Cookie HTTP header into a Cookie object. Returns
   * undefined if the string can't be parsed.
   *
   * The options parameter is not required and currently has only one property:
   *
   * - loose - boolean - if true enable parsing of key-less cookies like =abc and =, which are not RFC-compliant.
   * If options is not an object, it is ignored, which means you can use Array#map with it.
   *
   * Here's how to process the Set-Cookie header(s) on a node HTTP/HTTPS response:
   *
   * ```
   * if (res.headers['set-cookie'] instanceof Array)
   *   cookies = res.headers['set-cookie'].map(Cookie.parse);
   * else
   *   cookies = [Cookie.parse(res.headers['set-cookie'])];
   * ```
   */
  static parse (cookieString: string, options?: CookieParseOptions): Cookie;

  /**
   * the name or key of the cookie (default "")
   */
  key: string;

  /**
   * the value of the cookie (default "")
   */
  value: string;

  /**
   * if set, the Expires= attribute of the cookie (defaults to the string "Infinity").
   * See setExpires()
   */
  expires: Date;

  /**
   * (seconds) if set, the Max-Age= attribute in seconds of the cookie. May also
   * be set to strings "Infinity" and "-Infinity" for non-expiry and immediate-expiry,
   * respectively. See setMaxAge()
   */
  maxAge: number;

  /**
   * the Domain= attribute of the cookie
   */
  domain: string;

  /**
   * the Path= of the cookie
   */
  path: string;

  /**
   * the Secure cookie flag
   */
  secure: boolean;

  /**
   * the HttpOnly cookie flag
   */
  httpOnly: boolean;

  /**
   * any unrecognized cookie attributes as strings (even if equal-signs inside)
   */
  extensions: string[];

  /**
   * when this cookie was constructed
   */
  creation: Date;

  /**
   * set at construction, used to provide greater sort precision
   * (please see cookieCompare(a,b) for a full explanation)
   */
  creationIndex: number;

  /**
   * is this a host-only cookie (i.e. no Domain field was set, but was instead implied)
   */
  hostOnly: boolean;

  /**
   * if true, there was no Path field on the cookie and defaultPath() was used to derive one.
   */
  pathIsDefault: boolean;

  /**
   * last time the cookie got accessed. Will affect cookie cleaning once
   * implemented. Using cookiejar.getCookies(...) will update this attribute.
   */
  lastAccessed: Date;

  /**
   * encode to a Set-Cookie header value. The Expires cookie field is set
   * using formatDate(), but is omitted entirely if .expires is Infinity.
   */
  toString (): string;

  /**
   * encode to a Cookie header value (i.e. the .key and .value properties joined with '=').
   */
  cookieString (): string;

  /**
   * sets the expiry based on a date-string passed through parseDate(). If parseDate
   * returns null (i.e. can't parse this date string), .expires is set to "Infinity" (a string) is set.
   */
  setExpires (expires: string): void;

  /**
   * sets the maxAge in seconds. Coerces -Infinity to "-Infinity" and
   * Infinity to "Infinity" so it JSON serializes correctly.
   */
  setMaxAge (maxAge: number): void;

  /**
   * expiryTime() Computes the absolute unix-epoch milliseconds that this cookie
   * expires. expiryDate() works similarly, except it returns a Date object. Note
   * that in both cases the now parameter should be milliseconds.
   *
   * Max-Age takes precedence over Expires (as per the RFC). The .creation
   * attribute -- or, by default, the now paramter -- is used to offset the .maxAge attribute.
   *
   * If Expires (.expires) is set, that's returned.
   *
   * Otherwise, expiryTime() returns Infinity and expiryDate() returns a Date
   * object for "Tue, 19 Jan 2038 03:14:07 GMT" (latest date that can be
   * expressed by a 32-bit time_t; the common limit for most user-agents).
   */
  expiryTime (now?: number): number;
  expiryDate (now?: number): Date;

  /**
   * compute the TTL relative to now (milliseconds). The same precedence rules
   * as for expiryTime/expiryDate apply.
   *
   * The "number" Infinity is returned for cookies without an explicit
   * expiry and 0 is returned if the cookie is expired. Otherwise a time-to-live
   * in milliseconds is returned.
   */
  TTL (now?: number): number;

  /**
   * return the canonicalized .domain field. This is lower-cased and punycode
   * (RFC3490) encoded if the domain has any non-ASCII characters.
   */
  cdomain (): string;
  canonicalizedDomain (): string;

  /**
   * For convenience in using JSON.serialize(cookie). Returns a plain-old Object that can be JSON-serialized.
   *
   * Any Date properties (i.e., .expires, .creation, and .lastAccessed) are
   * exported in ISO format (.toISOString()).
   *
   * NOTE: Custom Cookie properties will be discarded. In tough-cookie 1.x, since
   * there was no .toJSON method explicitly defined, all enumerable properties were
   * captured. If you want a property to be serialized, add the property name to
   * the Cookie.serializableProperties Array.
   */
  toJSON (): Object;

  /**
   * Does the reverse of cookie.toJSON(). If passed a string, will JSON.parse() that first.
   *
   * Any Date properties (i.e., .expires, .creation, and .lastAccessed) are parsed
   * via Date.parse(), not the tough-cookie parseDate, since it's JavaScript/JSON-y
   * timestamps being handled at this layer.
   *
   * Returns null upon JSON parsing error.
   */
  static fromJSON (json: string): Cookie;

  /**
   * Does a deep clone of this cookie, exactly implemented as Cookie.fromJSON(cookie.toJSON()).
   */
  clone (): Cookie;
}

export interface CookieParseOptions {
  loose: boolean;
}

export interface SetCookieOptions {
  /**
   * default true - indicates if this is an HTTP or non-HTTP API. Affects HttpOnly cookies.
   */
  http?: boolean;

  /**
   * autodetect from url - indicates if this is a "Secure" API. If the currentUrl
   * starts with https: or wss: then this is defaulted to true, otherwise false.
   */
  secure?: boolean;

  /**
   * default new Date() - what to use for the creation/access time of cookies
   */
  now?: Date;

  /**
   * default false - silently ignore things like parse errors and invalid
   * domains. Store errors aren't ignored by this option.
   */
  ignoreError?: boolean;
}

export interface GetCookieOptions {
  /**
   * default true - indicates if this is an HTTP or non-HTTP API. Affects HttpOnly cookies.
   */
  http?: boolean;

  /**
   * autodetect from url - indicates if this is a "Secure" API. If the currentUrl
   * starts with https: or wss: then this is defaulted to true, otherwise false.
   */
  secure?: boolean;

  /**
   * default new Date() - what to use for the creation/access time of cookies
   */
  now?: Date;

  /**
   * default true - perform expiry-time checking of cookies and asynchronously
   * remove expired cookies from the store. Using false will return expired cookies
   * and not remove them from the store (which is useful for replaying Set-Cookie headers, potentially).
   */
  expire?: boolean;

  /**
   * default false - if true, do not scope cookies by path. The default uses
   * RFC-compliant path scoping. Note: may not be supported by the underlying
   * store (the default MemoryCookieStore supports it).
   */
  allPaths?: boolean;
}

export interface CookieJarOptions {
  /**
   * default true - reject cookies with domains like "com" and "co.uk"
   */
  rejectPublicSuffixes: boolean;

  /**
   * default false - accept malformed cookies like bar and =bar, which have an
   * implied empty name. This is not in the standard, but is used sometimes
   * on the web and is accepted by (most) browsers.
   */
  looseMode: boolean;
}

/**
 * Simply use new CookieJar(). If you'd like to use a custom store, pass that
 * to the constructor otherwise a MemoryCookieStore will be created and used.
 */
export class CookieJar {
  enableLooseMode: boolean;
  rejectPublicSuffixes: boolean;

  constructor (store?: Store, options?: boolean | CookieJarOptions);

  /**
   * Attempt to set the cookie in the cookie jar. If the operation fails, an
   * error will be given to the callback cb, otherwise the cookie is passed
   * through. The cookie will have updated .creation, .lastAccessed and .hostOnly properties.
   */
  setCookie (cookieOrString: string | Cookie, currentUrl: string, cb: (err: Error, cookie?: Cookie) => any): void;
  setCookie (cookieOrString: string | Cookie, currentUrl: string, options: SetCookieOptions, cb: (err: Error, cookie?: Cookie) => any): void;

  /**
   * Synchronous version of setCookie; only works with synchronous stores
   * (e.g. the default MemoryCookieStore).
   */
  setCookieSync (cookieOrString: string | Cookie, currentUrl: string, options?: SetCookieOptions): void;

  /**
   * Retrieve the list of cookies that can be sent in a Cookie header for the current url.
   *
   * If an error is encountered, that's passed as err to the callback, otherwise
   * an Array of Cookie objects is passed. The array is sorted with cookieCompare()
   * unless the {sort:false} option is given.
   */
  getCookies (currentUrl: string, cb: (err: Error, cookies?: Cookie[]) => any): void;
  getCookies (currentUrl: string, options: GetCookieOptions, cb: (err: Error, cookies?: Cookie[]) => any): void;

  /**
   * Synchronous version of getCookies; only works with synchronous stores
   * (e.g. the default MemoryCookieStore).
   */
  getCookiesSync (currentUrl: string, options?: GetCookieOptions): Cookie[];

  /**
   * Accepts the same options as .getCookies() but passes a string suitable
   * for a Cookie header rather than an array to the callback. Simply maps the
   * Cookie array via .cookieString().
   */
  getCookieString (currentUrl: string, cb: (err: Error, cookies?: string) => any): void;
  getCookieString (currentUrl: string, options: GetCookieOptions, cb: (err: Error, cookies?: string) => any): void;

  /**
   * Synchronous version of getCookieString; only works with synchronous stores
   * (e.g. the default MemoryCookieStore).
   */
  getCookieStringSync (currentUrl: string, options?: GetCookieOptions): string;

  /**
   * Serialize the Jar if the underlying store supports .getAllCookies.
   *
   * NOTE: Custom Cookie properties will be discarded. If you want a property
   * to be serialized, add the property name to the Cookie.serializableProperties Array.
   *
   * See [Serialization Format].
   */
  serialize (cb: (error: Error, serializedObject: Object) => any): void;

  /**
   * Sync version of .serialize
   */
  serializeSync (): Object;

  /**
   * Alias of .serializeSync() for the convenience of JSON.stringify(cookiejar).
   */
  toJSON (): Object;

  /**
   * A new Jar is created and the serialized Cookies are added to the
   * underlying store. Each Cookie is added via store.putCookie in the order
   * in which they appear in the serialization.
   *
   * The store argument is optional, but should be an instance of Store. By
   * default, a new instance of MemoryCookieStore is created.
   *
   * As a convenience, if serialized is a string, it is passed through
   * JSON.parse first. If that throws an error, this is passed to the callback.
   */
  static deserialize (serialized: string | Object, cb: (error: Error, object: Object) =>any): CookieJar;
  static deserialize (serialized: string | Object, store: Store, cb: (error: Error, object: Object) => any): CookieJar;

  /**
   * Sync version of .deserialize. Note that the store must be synchronous
   * for this to work.
   */
  static deserializeSync (serialized: string | Object, store: Store): Object;

  /**
   * Alias of .deserializeSync to provide consistency with Cookie.fromJSON().
   */
  static fromJSON (string: string): Object;

  /**
   * Produces a deep clone of this jar. Modifications to the original won't
   * affect the clone, and vice versa.
   *
   * The store argument is optional, but should be an instance of Store. By
   * default, a new instance of MemoryCookieStore is created. Transferring
   * between store types is supported so long as the source implements
   * .getAllCookies() and the destination implements .putCookie().
   */
  clone (cb: (error: Error, newJar: CookieJar) => any): void;
  clone (store: Store, cb: (error: Error, newJar: CookieJar) => any): void;

  /**
   * Synchronous version of .clone, returning a new CookieJar instance.
   *
   * The store argument is optional, but must be a synchronous Store instance
   * if specified. If not passed, a new instance of MemoryCookieStore is used.
   *
   * The source and destination must both be synchronous Stores. If one or both
   * stores are asynchronous, use .clone instead. Recall that MemoryCookieStore
   * supports both synchronous and asynchronous API calls.
   */
  cloneSync (store?: Store): CookieJar;
}
}

// Generated by typings
// Source: https://raw.githubusercontent.com/louy/typed-request/8dbbc8c9c3aee44d1ca00ac82a88a00f37198e1d/index.d.ts
declare module '~sp-request~request' {
import {Stream} from 'stream';
import {Agent, ClientRequest, IncomingMessage} from 'http';
import * as FormData from '~sp-request~request~form-data';
import * as toughCookie from '~sp-request~request~tough-cookie';

var request: request.RequestAPI<request.Request, request.CoreOptions, request.RequiredUriUrl>;

namespace request {
  export interface RequestAPI<TRequest extends Request,
    TOptions extends CoreOptions,
    TUriUrlOptions> {

    defaults(options: TOptions): RequestAPI<TRequest, TOptions, RequiredUriUrl>;
    defaults(options: RequiredUriUrl & TOptions): DefaultUriUrlRequestApi<TRequest, TOptions, OptionalUriUrl>;

    (uri: string, options?: TOptions, callback?: RequestCallback): TRequest;
    (uri: string, callback?: RequestCallback): TRequest;
    (options: TUriUrlOptions & TOptions, callback?: RequestCallback): TRequest;

    get(uri: string, options?: TOptions, callback?: RequestCallback): TRequest;
    get(uri: string, callback?: RequestCallback): TRequest;
    get(options: TUriUrlOptions & TOptions, callback?: RequestCallback): TRequest;

    post(uri: string, options?: TOptions, callback?: RequestCallback): TRequest;
    post(uri: string, callback?: RequestCallback): TRequest;
    post(options: TUriUrlOptions & TOptions, callback?: RequestCallback): TRequest;

    put(uri: string, options?: TOptions, callback?: RequestCallback): TRequest;
    put(uri: string, callback?: RequestCallback): TRequest;
    put(options: TUriUrlOptions & TOptions, callback?: RequestCallback): TRequest;

    head(uri: string, options?: TOptions, callback?: RequestCallback): TRequest;
    head(uri: string, callback?: RequestCallback): TRequest;
    head(options: TUriUrlOptions & TOptions, callback?: RequestCallback): TRequest;

    patch(uri: string, options?: TOptions, callback?: RequestCallback): TRequest;
    patch(uri: string, callback?: RequestCallback): TRequest;
    patch(options: TUriUrlOptions & TOptions, callback?: RequestCallback): TRequest;

    del(uri: string, options?: TOptions, callback?: RequestCallback): TRequest;
    del(uri: string, callback?: RequestCallback): TRequest;
    del(options: TUriUrlOptions & TOptions, callback?: RequestCallback): TRequest;

    forever(agentOptions: any, optionsArg: any): TRequest;
    jar(): CookieJar;
    cookie(str: string): Cookie;

    initParams: any;
    debug: boolean;
  }

  interface DefaultUriUrlRequestApi<TRequest extends Request,
    TOptions extends CoreOptions,
    TUriUrlOptions>	extends RequestAPI<TRequest, TOptions, TUriUrlOptions> {

    defaults(options: TOptions): DefaultUriUrlRequestApi<TRequest, TOptions, OptionalUriUrl>;
    defaults(options: RequiredUriUrl & TOptions): DefaultUriUrlRequestApi<TRequest, TOptions, OptionalUriUrl>;
    (): TRequest;
    get(): TRequest;
    post(): TRequest;
    put(): TRequest;
    head(): TRequest;
    patch(): TRequest;
    del(): TRequest;
  }

  interface CoreOptions {
    baseUrl?: string;
    callback?: (error: any, response: IncomingMessage, body: any) => void;
    jar?: boolean | CookieJar;
    formData?: any; // Object
    form?: any; // Object or string
    auth?: AuthOptions;
    oauth?: OAuthOptions;
    aws?: AWSOptions;
    hawk?: HawkOptions;
    qs?: any;
    json?: any;
    multipart?: RequestPart[] | Multipart;
    agentOptions?: any;
    agentClass?: any;
    forever?: any;
    host?: string;
    port?: number;
    method?: string;
    headers?: Headers;
    body?: any;
    followRedirect?: boolean | ((response: IncomingMessage) => boolean);
    followAllRedirects?: boolean;
    maxRedirects?: number;
    encoding?: string;
    pool?: any;
    timeout?: number;
    proxy?: any;
    strictSSL?: boolean;
    gzip?: boolean;
    preambleCRLF?: boolean;
    postambleCRLF?: boolean;
    key?: Buffer;
    cert?: Buffer;
    passphrase?: string;
    ca?: Buffer;
    har?: HttpArchiveRequest;
    useQuerystring?: boolean;
  }

  interface UriOptions {
    uri: string;
  }
  interface UrlOptions {
    url: string;
  }
  export type RequiredUriUrl = UriOptions | UrlOptions;

  interface OptionalUriUrl {
    uri?: string;
    url?: string;
  }

      export type OptionsWithUri = UriOptions & CoreOptions;
      export type OptionsWithUrl = UrlOptions & CoreOptions;
      export type Options = OptionsWithUri | OptionsWithUrl;

  export interface RequestCallback {
    (error: any, response: IncomingMessage, body: any): void;
  }

  export interface HttpArchiveRequest {
    url?: string;
    method?: string;
    headers?: NameValuePair[];
    postData?: {
      mimeType?: string;
      params?: NameValuePair[];
    };
  }

  export interface NameValuePair {
    name: string;
    value: string;
  }

  export interface Multipart {
    chunked?: boolean;
    data?: {
      'content-type'?: string,
      body: string
    }[];
  }

  export interface RequestPart {
    headers?: Headers;
    body: any;
  }

  export interface Request extends Stream {
    readable: boolean;
    writable: boolean;

    getAgent(): Agent;
    // start(): void;
    // abort(): void;
    pipeDest(dest: any): void;
    setHeader(name: string, value: string, clobber?: boolean): Request;
    setHeaders(headers: Headers): Request;
    qs(q: Object, clobber?: boolean): Request;
    form(): FormData;
    form(form: any): Request;
    multipart(multipart: RequestPart[]): Request;
    json(val: any): Request;
    aws(opts: AWSOptions, now?: boolean): Request;
    auth(username: string, password: string, sendInmediately?: boolean, bearer?: string): Request;
    oauth(oauth: OAuthOptions): Request;
    jar(jar: CookieJar): Request;

    on(event: string, listener: Function): this;
    on(event: 'request', listener: (req: ClientRequest) => void): this;
    on(event: 'response', listener: (resp: IncomingMessage) => void): this;
    on(event: 'data', listener: (data: Buffer | string) => void): this;
    on(event: 'error', listener: (e: Error) => void): this;
    on(event: 'complete', listener: (resp: IncomingMessage, body?: string | Buffer) => void): this;

    write(buffer: Buffer, cb?: Function): boolean;
    write(str: string, cb?: Function): boolean;
    write(str: string, encoding: string, cb?: Function): boolean;
    write(str: string, encoding?: string, fd?: string): boolean;
    end(): void;
    end(chunk: Buffer, cb?: Function): void;
    end(chunk: string, cb?: Function): void;
    end(chunk: string, encoding: string, cb?: Function): void;
    pause(): void;
    resume(): void;
    abort(): void;
    destroy(): void;
    toJSON(): Object;
  }

  export interface Headers {
    [key: string]: any;
  }

  export interface AuthOptions {
    user?: string;
    username?: string;
    pass?: string;
    password?: string;
    sendImmediately?: boolean;
    bearer?: string;
  }

  export interface OAuthOptions {
    callback?: string;
    consumer_key?: string;
    consumer_secret?: string;
    token?: string;
    token_secret?: string;
    verifier?: string;
  }

  export interface HawkOptions {
    credentials: any;
  }

  export interface AWSOptions {
    secret: string;
    bucket?: string;
  }

  /**
   * Cookies
   */
  // Request wraps the `tough-cookies`'s CookieJar in a synchronous RequestJar
  // https://github.com/request/request/blob/master/lib/cookies.js
  export type Cookie = toughCookie.Cookie;
  export type CookieStore = toughCookie.Store;
  export type SetCookieOptions = toughCookie.SetCookieOptions;

  export interface CookieJar {
    // RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
    //   var self = this
    //   return self._jar.setCookieSync(cookieOrStr, uri, options || {})
    // }
    setCookie(cookieOrString: Cookie | string, uri: string, options?: SetCookieOptions): Cookie;

    // RequestJar.prototype.getCookieString = function(uri) {
    //   var self = this
    //   return self._jar.getCookieStringSync(uri)
    // }
    getCookieString(uri: string): string;

    // RequestJar.prototype.getCookies = function(uri) {
    //   var self = this
    //   return self._jar.getCookiesSync(uri)
    // }
    getCookies(uri: string): Cookie[];
  }
}

export = request;
}

// Generated by typings
// Source: node_modules/sp-request/lib/src/core/IncomingMessageWithBody.d.ts
declare module '~sp-request/lib/src/core/IncomingMessageWithBody' {
module 'http' {
    interface IncomingMessage {
        body: any;
    }
}
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-bluebird/92126fa3d066d07af9e93068e10a6800567c0551/bluebird.d.ts
declare module '~sp-request~bluebird' {
// Type definitions for Bluebird v3.x.x
// Project: http://bluebirdjs.com

class Bluebird<R> implements Bluebird.Thenable<R>, Bluebird.Inspection<R> {
  /**
   * Create a new promise. The passed in function will receive functions `resolve` and `reject` as its arguments which can be called to seal the fate of the created promise.
   */
  constructor(callback: (resolve: (thenableOrResult: R | Bluebird.Thenable<R>) => void, reject: (error: any) => void) => void);

  /**
   * Promises/A+ `.then()`. Returns a new promise chained from this promise. The new promise will be rejected or resolved dedefer on the passed `fulfilledHandler`, `rejectedHandler` and the state of this promise.
   */
  then<U>(onFulfill: (value: R) => U | Bluebird.Thenable<U>, onReject?: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U>;
  then<U>(onFulfill: (value: R) => U | Bluebird.Thenable<U>, onReject?: (error: any) => void | Bluebird.Thenable<void>): Bluebird<U>;

  /**
   * This is a catch-all exception handler, shortcut for calling `.then(null, handler)` on this promise. Any exception happening in a `.then`-chain will propagate to nearest `.catch` handler.
   *
   * Alias `.caught();` for compatibility with earlier ECMAScript version.
   */
  catch(onReject?: (error: any) => R | Bluebird.Thenable<R> | void | Bluebird.Thenable<void>): Bluebird<R>;
  catch<U>(onReject?: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U | R>;

  /**
   * This extends `.catch` to work more like catch-clauses in languages like Java or C#. Instead of manually checking `instanceof` or `.name === "SomeError"`, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.
   *
   * This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.
   *
   * Alias `.caught();` for compatibility with earlier ECMAScript version.
   */
  catch(predicate: (error: any) => boolean, onReject: (error: any) => R | Bluebird.Thenable<R> | void | Bluebird.Thenable<void>): Bluebird<R>;
  catch<U>(predicate: (error: any) => boolean, onReject: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U | R>;
  catch(ErrorClass: Function, onReject: (error: any) => R | Bluebird.Thenable<R> | void | Bluebird.Thenable<void>): Bluebird<R>;
  catch<U>(ErrorClass: Function, onReject: (error: any) => U | Bluebird.Thenable<U>): Bluebird<U | R>;

  /**
   * Like `.catch` but instead of catching all types of exceptions, it only catches those that don't originate from thrown errors but rather from explicit rejections.
   */
  error<U>(onReject: (reason: any) => Bluebird.Thenable<U>): Bluebird<U>;
  error<U>(onReject: (reason: any) => U): Bluebird<U>;

  /**
   * Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for `.finally()` in that the final value cannot be modified from the handler.
   *
   * Alias `.lastly();` for compatibility with earlier ECMAScript version.
   */
  finally<U>(handler: () => Bluebird.Thenable<U>): Bluebird<R>;
  finally<U>(handler: () => U): Bluebird<R>;

  lastly<U>(handler: () => Bluebird.Thenable<U>): Bluebird<R>;
  lastly<U>(handler: () => U): Bluebird<R>;

  /**
   * Create a promise that follows this promise, but is bound to the given `thisArg` value. A bound promise will call its handlers with the bound value set to `this`. Additionally promises derived from a bound promise will also be bound promises with the same `thisArg` binding as the original promise.
   */
  bind(thisArg: any): Bluebird<R>;

  /**
   * Like `.then()`, but any unhandled rejection that ends up here will be thrown as an error.
   */
  done<U>(onFulfilled: (value: R) => Bluebird.Thenable<U>, onRejected: (error: any) => Bluebird.Thenable<U>): void;
  done<U>(onFulfilled: (value: R) => Bluebird.Thenable<U>, onRejected?: (error: any) => U): void;
  done<U>(onFulfilled: (value: R) => U, onRejected: (error: any) => Bluebird.Thenable<U>): void;
  done<U>(onFulfilled?: (value: R) => U, onRejected?: (error: any) => U): void;

  /**
   * Like `.finally()`, but not called for rejections.
   */
  tap<U>(onFulFill: (value: R) => Bluebird.Thenable<U>): Bluebird<R>;
  tap<U>(onFulfill: (value: R) => U): Bluebird<R>;

  /**
   * Same as calling `Promise.delay(ms, this)`.
   */
  delay(ms: number): Bluebird<R>;

  /**
   * Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason.
   *  However, if this promise is not fulfilled or rejected within ms milliseconds, the returned promise
   *  is rejected with a TimeoutError or the error as the reason.
   *
   * You may specify a custom error message with the `message` parameter.
   */
  timeout(ms: number, message?: string | Error): Bluebird<R>;

  /**
   * Register a node-style callback on this promise. When this promise is is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be `null` in case of success.
   * If the `callback` argument is not a function, this method does not do anything.
   */
  nodeify(callback: (err: any, value?: R) => void, options?: Bluebird.SpreadOption): this;
  nodeify(...sink: any[]): this;
  asCallback(callback: (err: any, value?: R) => void, options?: Bluebird.SpreadOption): this;
  asCallback(...sink: any[]): this;

  /**
   * See if this `promise` has been fulfilled.
   */
  isFulfilled(): boolean;

  /**
   * See if this `promise` has been rejected.
   */
  isRejected(): boolean;

  /**
   * See if this `promise` is still defer.
   */
  isPending(): boolean;

  /**
   * See if this `promise` is resolved -> either fulfilled or rejected.
   */
  isResolved(): boolean;

  /**
   * Get the fulfillment value of the underlying promise. Throws if the promise isn't fulfilled yet.
   *
   * throws `TypeError`
   */
  value(): R;

  /**
   * Get the rejection reason for the underlying promise. Throws if the promise isn't rejected yet.
   *
   * throws `TypeError`
   */
  reason(): any;

  /**
   * Synchronously inspect the state of this `promise`. The `PromiseInspection` will represent the state of
   * the promise as snapshotted at the time of calling `.reflect()`.
   */
  reflect(): Bluebird.Inspection<R>;

  /**
   * This is a convenience method for doing:
   *
   * <code>
   * promise.then(function(obj){
   *     return obj[propertyName].call(obj, arg...);
   * });
   * </code>
   */
  call(propertyName: string, ...args: any[]): Bluebird<any>;

  /**
   * This is a convenience method for doing:
   *
   * <code>
   * promise.then(function(obj){
   *     return obj[propertyName];
   * });
   * </code>
   */
  // TODO: Use "type property type" once it's there
  // @see https://github.com/Microsoft/TypeScript/issues/1295
  get<U>(key: string | number): Bluebird<U>;

  /**
   * Convenience method for:
   *
   * <code>
   * .then(function() {
   *    return value;
   * });
   * </code>
   *
   * in the case where `value` doesn't change its value. That means `value` is bound at the time of calling `.return()`
   *
   * Alias `.thenReturn();` for compatibility with earlier ECMAScript version.
   */
  return(): Bluebird<any>;
  thenReturn(): Bluebird<any>;
  return<U>(value: U): Bluebird<U>;
  thenReturn<U>(value: U): Bluebird<U>;

  /**
   * Convenience method for:
   *
   * <code>
   * .then(function() {
   *    throw reason;
   * });
   * </code>
   * Same limitations apply as with `.return()`.
   *
   * Alias `.thenThrow();` for compatibility with earlier ECMAScript version.
   */
  throw(reason: Error): Bluebird<R>;
  thenThrow(reason: Error): Bluebird<R>;

  /**
   * Convert to String.
   */
  toString(): string;

  /**
   * This is implicitly called by `JSON.stringify` when serializing the object. Returns a serialized representation of the `Promise`.
   */
  toJSON(): Object;

  /**
   * Like calling `.then`, but the fulfillment value or rejection reason is assumed to be an array, which is flattened to the formal parameters of the handlers.
   */
  spread<U, W>(fulfilledHandler: (...values: W[]) => U | Bluebird.Thenable<U>): Bluebird<U>;
  spread<U>(fulfilledHandler: Function): Bluebird<U>;
  spread<U>(fulfilledHandler: Function): Bluebird<U>;

  /**
   * Same as calling `Promise.all(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  all<U>(): Bluebird<U[]>;

  /**
   * Same as calling `Promise.props(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO how to model instance.props()?
  props(): Bluebird<Object>;

  /**
   * Same as calling `Promise.any(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  any<U>(): Bluebird<U>;

  /**
   * Same as calling `Promise.some(thisPromise)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  some<U>(count: number): Bluebird<U[]>;

  /**
   * Same as calling `Promise.race(thisPromise, count)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  race<U>(): Bluebird<U>;

  /**
   * Same as calling `Bluebird.map(thisPromise, mapper)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  map<Q, U>(mapper: (item: Q, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  map<Q, U>(mapper: (item: Q, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  /**
   * Same as calling `Promise.reduce(thisPromise, Function reducer, initialValue)`. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  reduce<Q, U>(reducer: (memo: U, item: Q, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  reduce<Q, U>(reducer: (memo: U, item: Q, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  /**
   * Same as calling ``Promise.filter(thisPromise, filterer)``. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  // TODO type inference from array-resolving promise?
  filter<U>(filterer: (item: U, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  filter<U>(filterer: (item: U, index: number, arrayLength: number) => boolean, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  /**
   * Same as calling ``Bluebird.each(thisPromise, iterator)``. With the exception that if this promise is bound to a value, the returned promise is bound to that value too.
   */
  each<R, U>(iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;

  /**
   * Start the chain of promises with `Promise.try`. Any synchronous exceptions will be turned into rejections on the returned promise.
   *
   * Note about second argument: if it's specifically a true array, its values become respective arguments for the function call. Otherwise it is passed as is as the first argument for the function call.
   *
   * Alias for `attempt();` for compatibility with earlier ECMAScript version.
   */
  static try<R>(fn: () => Bluebird.Thenable<R>): Bluebird<R>;
  static try<R>(fn: () => R): Bluebird<R>;

  static attempt<R>(fn: () => Bluebird.Thenable<R>): Bluebird<R>;
  static attempt<R>(fn: () => R): Bluebird<R>;

  /**
   * Returns a new function that wraps the given function `fn`. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.
   * This method is convenient when a function can sometimes return synchronously or throw synchronously.
   */
  static method(fn: Function): Function;

  /**
   * Create a promise that is resolved with the given `value`. If `value` is a thenable or promise, the returned promise will assume its state.
   */
  static resolve(): Bluebird<void>;
  static resolve<R>(value: Bluebird.Thenable<R>): Bluebird<R>;
  static resolve<R>(value: R): Bluebird<R>;

  /**
   * Create a promise that is rejected with the given `reason`.
   */
  static reject(reason: any): Bluebird<any>;
  static reject<R>(reason: any): Bluebird<R>;

  /**
   * Create a promise with undecided fate and return a `PromiseResolver` to control it. See resolution?: Promise(#promise-resolution).
   */
  static defer<R>(): Bluebird.Resolver<R>;

  /**
   * Cast the given `value` to a trusted promise. If `value` is already a trusted `Promise`, it is returned as is. If `value` is not a thenable, a fulfilled is: Promise returned with `value` as its fulfillment value. If `value` is a thenable (Promise-like object, like those returned by jQuery's `$.ajax`), returns a trusted that: Promise assimilates the state of the thenable.
   */
  static cast<R>(value: Bluebird.Thenable<R>): Bluebird<R>;
  static cast<R>(value: R): Bluebird<R>;

  /**
   * Sugar for `Promise.resolve(undefined).bind(thisArg);`. See `.bind()`.
   */
  static bind(thisArg: any): Bluebird<void>;

  /**
   * See if `value` is a trusted Promise.
   */
  static is(value: any): boolean;

  /**
   * Call this right after the library is loaded to enabled long stack traces. Long stack traces cannot be disabled after being enabled, and cannot be enabled after promises have already been created. Long stack traces imply a substantial performance penalty, around 4-5x for throughput and 0.5x for latency.
   */
  static longStackTraces(): void;

  /**
   * Returns a promise that will be resolved with value (or undefined) after given ms milliseconds.
   * If value is a promise, the delay will start counting down when it is fulfilled and the returned
   *  promise will be fulfilled with the fulfillment value of the value promise.
   */
  static delay<R>(ms: number, value: R | Bluebird.Thenable<R>): Bluebird<R>;
  static delay(ms: number): Bluebird<void>;

  /**
   * Returns a function that will wrap the given `nodeFunction`. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.
   *
   * If the `nodeFunction` calls its callback with multiple success values, the fulfillment value will be an array of them.
   *
   * If you pass a `receiver`, the `nodeFunction` will be called as a method on the `receiver`.
   */
  static promisify<T>(func: (callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): () => Bluebird<T>;
  static promisify<T, A1>(func: (arg1: A1, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1) => Bluebird<T>;
  static promisify<T, A1, A2>(func: (arg1: A1, arg2: A2, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2) => Bluebird<T>;
  static promisify<T, A1, A2, A3>(func: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2, arg3: A3) => Bluebird<T>;
  static promisify<T, A1, A2, A3, A4>(func: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Bluebird<T>;
  static promisify<T, A1, A2, A3, A4, A5>(func: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, result: T) => void) => void, options?: Bluebird.PromisifyOptions): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Bluebird<T>;
  static promisify(nodeFunction: Function, options?: Bluebird.PromisifyOptions): Function;

  /**
   * Promisifies the entire object by going through the object's properties and creating an async equivalent of each function on the object and its prototype chain. The promisified method name will be the original method name postfixed with `Async`. Returns the input object.
   *
   * Note that the original methods on the object are not overwritten but new methods are created with the `Async`-postfix. For example, if you `promisifyAll()` the node.js `fs` object use `fs.statAsync()` to call the promisified `stat` method.
   */
  // TODO how to model promisifyAll?
  static promisifyAll(target: Object, options?: Bluebird.PromisifyAllOptions): Object;

  /**
   * Returns a promise that is resolved by a node style callback function.
   */
  static fromNode(resolver: (callback: (err: any, result?: any) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<any>;
  static fromNode<T>(resolver: (callback: (err: any, result?: T) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<T>;
  static fromCallback(resolver: (callback: (err: any, result?: any) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<any>;
  static fromCallback<T>(resolver: (callback: (err: any, result?: T) => void) => void, options?: Bluebird.FromNodeOptions): Bluebird<T>;

  /**
   * Returns a function that can use `yield` to run asynchronous code synchronously. This feature requires the support of generators which are drafted in the next version of the language. Node version greater than `0.11.2` is required and needs to be executed with the `--harmony-generators` (or `--harmony`) command-line switch.
   */
  // TODO fix coroutine GeneratorFunction
  static coroutine<R>(generatorFunction: Function): Function;

  /**
   * Add `handler` as the handler to call when there is a possibly unhandled rejection. The default handler logs the error stack to stderr or `console.error` in browsers.
   *
   * Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.
   */
  static onPossiblyUnhandledRejection(handler: (reason: any) => any): void;

  /**
   * Given an array, or a promise of an array, which contains promises (or a mix of promises and values) return a promise that is fulfilled when all the items in the array are fulfilled. The promise's fulfillment value is an array with fulfillment values at respective positions to the original array. If any promise in the array rejects, the returned promise is rejected with the rejection reason.
   */
  // TODO enable more overloads
  // array with promises of different types
  static all<T1>(values: [Bluebird.Thenable<T1> | T1]): Bluebird<[T1]>;
  static all<T1, T2>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2]): Bluebird<[T1, T2]>;
  static all<T1, T2, T3>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2, Bluebird.Thenable<T3> | T3]): Bluebird<[T1, T2, T3]>;
  static all<T1, T2, T3, T4>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2, Bluebird.Thenable<T3> | T3, Bluebird.Thenable<T4> | T4]): Bluebird<[T1, T2, T3, T4]>;
  static all<T1, T2, T3, T4, T5>(values: [Bluebird.Thenable<T1> | T1, Bluebird.Thenable<T2> | T2, Bluebird.Thenable<T3> | T3, Bluebird.Thenable<T4> | T4, Bluebird.Thenable<T5> | T5]): Bluebird<[T1, T2, T3, T4, T5]>;
  // array with values
  static all<R>(values: ((R | Bluebird.Thenable<R>) | Bluebird.Thenable<(R | Bluebird.Thenable<R>)>)[]): Bluebird<R[]>;

  /**
   * Like ``Promise.all`` but for object properties instead of array items. Returns a promise that is fulfilled when all the properties of the object are fulfilled. The promise's fulfillment value is an object with fulfillment values at respective keys to the original object. If any promise in the object rejects, the returned promise is rejected with the rejection reason.
   *
   * If `object` is a trusted `Promise`, then it will be treated as a promise for object rather than for its properties. All other objects are treated for their properties as is returned by `Object.keys` - the object's own enumerable properties.
   *
   * *The original object is not modified.*
   */
  // TODO verify this is correct
  // trusted promise for object
  static props(object: Bluebird<Object>): Bluebird<Object>;
  // object
  static props(object: Object): Bluebird<Object>;

  /**
   * Like `Promise.some()`, with 1 as `count`. However, if the promise fulfills, the fulfillment value is not an array of 1 but the value directly.
   */
  // promise of array with promises of value
  static any<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>): Bluebird<R>;
  // promise of array with values
  static any<R>(values: Bluebird.Thenable<R[]>): Bluebird<R>;
  // array with promises of value
  static any<R>(values: Bluebird.Thenable<R>[]): Bluebird<R>;
  // array with values
  static any<R>(values: R[]): Bluebird<R>;

  /**
   * Given an array, or a promise of an array, which contains promises (or a mix of promises and values) return a promise that is fulfilled or rejected as soon as a promise in the array is fulfilled or rejected with the respective rejection reason or fulfillment value.
   *
   * **Note** If you pass empty array or a sparse array with no values, or a promise/thenable for such, it will be forever pending.
   */
  // promise of array with promises of value
  static race<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>): Bluebird<R>;
  // promise of array with values
  static race<R>(values: Bluebird.Thenable<R[]>): Bluebird<R>;
  // array with promises of value
  static race<R>(values: Bluebird.Thenable<R>[]): Bluebird<R>;
  // array with values
  static race<R>(values: R[]): Bluebird<R>;

  /**
   * Initiate a competetive race between multiple promises or values (values will become immediately fulfilled promises). When `count` amount of promises have been fulfilled, the returned promise is fulfilled with an array that contains the fulfillment values of the winners in order of resolution.
   *
   * If too many promises are rejected so that the promise can never become fulfilled, it will be immediately rejected with an array of rejection reasons in the order they were thrown in.
   *
   * *The original array is not modified.*
   */
  // promise of array with promises of value
  static some<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, count: number): Bluebird<R[]>;
  // promise of array with values
  static some<R>(values: Bluebird.Thenable<R[]>, count: number): Bluebird<R[]>;
  // array with promises of value
  static some<R>(values: Bluebird.Thenable<R>[], count: number): Bluebird<R[]>;
  // array with values
  static some<R>(values: R[], count: number): Bluebird<R[]>;

  /**
   * Promise.join(
   *   Promise<any>|any values...,
   *   function handler
   * ) -> Promise
   * For coordinating multiple concurrent discrete promises.
   *
   * Note: In 1.x and 0.x Promise.join used to be a Promise.all that took the values in as arguments instead in an array. This behavior has been deprecated but is still supported partially - when the last argument is an immediate function value the new semantics will apply
   */
  static join<R, A1>(arg1: A1 | Bluebird.Thenable<A1>, handler: (arg1?: A1) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, handler: (arg1?: A1, arg2?: A2) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2, A3>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, arg3: A3 | Bluebird.Thenable<A3>, handler: (arg1?: A1, arg2?: A2, arg3?: A3) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2, A3, A4>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, arg3: A3 | Bluebird.Thenable<A3>, arg4: A4 | Bluebird.Thenable<A4>, handler: (arg1?: A1, arg2?: A2, arg3?: A3, arg4?: A4) => R | Bluebird.Thenable<R>): Bluebird<R>;
  static join<R, A1, A2, A3, A4, A5>(arg1: A1 | Bluebird.Thenable<A1>, arg2: A2 | Bluebird.Thenable<A2>, arg3: A3 | Bluebird.Thenable<A3>, arg4: A4 | Bluebird.Thenable<A4>, arg5: A5 | Bluebird.Thenable<A5>, handler: (arg1?: A1, arg2?: A2, arg3?: A3, arg4?: A4, arg5?: A5) => R | Bluebird.Thenable<R>): Bluebird<R>;

  // variadic array
  /** @deprecated use .all instead */
  static join<R>(...values: (R | Bluebird.Thenable<R>)[]): Bluebird<R[]>;

  /**
   * Map an array, or a promise of an array, which contains a promises (or a mix of promises and values) with the given `mapper` function with the signature `(item, index, arrayLength)` where `item` is the resolved value of a respective promise in the input array. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * If the `mapper` function returns promises or thenables, the returned promise will wait for all the mapped results to be resolved as well.
   *
   * *The original array is not modified.*
   */
  // promise of array with promises of value
  static map<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  // promise of array with values
  static map<R, U>(values: Bluebird.Thenable<R[]>, mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: Bluebird.Thenable<R[]>, mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  // array with promises of value
  static map<R, U>(values: Bluebird.Thenable<R>[], mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: Bluebird.Thenable<R>[], mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  // array with values
  static map<R, U>(values: R[], mapper: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;
  static map<R, U>(values: R[], mapper: (item: R, index: number, arrayLength: number) => U, options?: Bluebird.ConcurrencyOption): Bluebird<U[]>;

  /**
   * Reduce an array, or a promise of an array, which contains a promises (or a mix of promises and values) with the given `reducer` function with the signature `(total, current, index, arrayLength)` where `item` is the resolved value of a respective promise in the input array. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * If the reducer function returns a promise or a thenable, the result for the promise is awaited for before continuing with next iteration.
   *
   * *The original array is not modified. If no `intialValue` is given and the array doesn't contain at least 2 items, the callback will not be called and `undefined` is returned. If `initialValue` is given and the array doesn't have at least 1 item, `initialValue` is returned.*
   */
  // promise of array with promises of value
  static reduce<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  // promise of array with values
  static reduce<R, U>(values: Bluebird.Thenable<R[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: Bluebird.Thenable<R[]>, reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  // array with promises of value
  static reduce<R, U>(values: Bluebird.Thenable<R>[], reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: Bluebird.Thenable<R>[], reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  // array with values
  static reduce<R, U>(values: R[], reducer: (total: U, current: R, index: number, arrayLength: number) => Bluebird.Thenable<U>, initialValue?: U): Bluebird<U>;
  static reduce<R, U>(values: R[], reducer: (total: U, current: R, index: number, arrayLength: number) => U, initialValue?: U): Bluebird<U>;

  /**
   * Filter an array, or a promise of an array, which contains a promises (or a mix of promises and values) with the given `filterer` function with the signature `(item, index, arrayLength)` where `item` is the resolved value of a respective promise in the input array. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * The return values from the filtered functions are coerced to booleans, with the exception of promises and thenables which are awaited for their eventual result.
   *
   * *The original array is not modified.
   */
  // promise of array with promises of value
  static filter<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  // promise of array with values
  static filter<R>(values: Bluebird.Thenable<R[]>, filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: Bluebird.Thenable<R[]>, filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  // array with promises of value
  static filter<R>(values: Bluebird.Thenable<R>[], filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: Bluebird.Thenable<R>[], filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  // array with values
  static filter<R>(values: R[], filterer: (item: R, index: number, arrayLength: number) => Bluebird.Thenable<boolean>, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;
  static filter<R>(values: R[], filterer: (item: R, index: number, arrayLength: number) => boolean, option?: Bluebird.ConcurrencyOption): Bluebird<R[]>;

  /**
   * Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given iterator function with the signature (item, index, value) where item is the resolved value of a respective promise in the input array. Iteration happens serially. If any promise in the input array is rejected the returned promise is rejected as well.
   *
   * Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator function returns a promise or a thenable, the result for the promise is awaited for before continuing with next iteration.
   */
  // promise of array with promises of value
  static each<R, U>(values: Bluebird.Thenable<Bluebird.Thenable<R>[]>, iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;
  // array with promises of value
  static each<R, U>(values: Bluebird.Thenable<R>[], iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;
  // array with values OR promise of array with values
  static each<R, U>(values: R[] | Bluebird.Thenable<R[]>, iterator: (item: R, index: number, arrayLength: number) => U | Bluebird.Thenable<U>): Bluebird<R[]>;

  /**
   * A meta method used to specify the disposer method that cleans up a resource when using `Promise.using`.
   *
   * Returns a Disposer object which encapsulates both the resource as well as the method to clean it up.
   *  The user can pass this object to `Promise.using` to get access to the resource when it becomes available,
   *  as well as to ensure its automatically cleaned up.
   *
   * The second argument passed to a disposer is the result promise of the using block, which you can
   *  inspect synchronously.
   */
  disposer(disposeFn: (arg: R, promise: Bluebird<R>) => void | Bluebird.Thenable<void>): Bluebird.Disposer<R>;

  /**
   * In conjunction with `.disposer`, using will make sure that no matter what, the specified disposer
   *  will be called when the promise returned by the callback passed to using has settled. The disposer is
   *  necessary because there is no standard interface in node for disposing resources.
   */
  static using<R, T>(disposer: Bluebird.Disposer<R>, executor: (transaction: R) => Bluebird.Thenable<T>): Bluebird<T>;
  static using<R1, R2, T>(disposer: Bluebird.Disposer<R1>, disposer2: Bluebird.Disposer<R2>, executor: (transaction1: R1, transaction2: R2) => Bluebird.Thenable<T>): Bluebird<T>;
  static using<R1, R2, R3, T>(disposer: Bluebird.Disposer<R1>, disposer2: Bluebird.Disposer<R2>, disposer3: Bluebird.Disposer<R3>, executor: (transaction1: R1, transaction2: R2, transaction3: R3) => Bluebird.Thenable<T>): Bluebird<T>;

  /**
   * Add handler as the handler to call when there is a possibly unhandled rejection.
   * The default handler logs the error stack to stderr or console.error in browsers.
   *
   * Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.
   *
   * Note: this hook is specific to the bluebird instance its called on, application developers should use global rejection events.
   */
  static onPossiblyUnhandledRejection(handler?: (error: Error, promise: Bluebird<any>) => void): void;

  /**
   * Configure long stack traces, warnings, monitoring and cancellation.
   * Note that even though false is the default here, a development environment might be detected which automatically
   *  enables long stack traces and warnings.
   */
  static config(options: {
    /** Enable warnings */
    warnings?: boolean | {
      /** Enables all warnings except forgotten return statements. */
      wForgottenReturn: boolean;
    };
    /** Enable long stack traces */
    longStackTraces?: boolean;
    /** Enable cancellation */
    cancellation?: boolean;
    /** Enable monitoring */
    monitoring?: boolean;
  }): void;
}

namespace Bluebird {
  export interface ConcurrencyOption {
    concurrency: number;
  }
  export interface SpreadOption {
    spread: boolean;
  }
  export interface FromNodeOptions {
    multiArgs?: boolean;
  }
  export interface PromisifyOptions {
    context?: any;
    multiArgs?: boolean;
  }
  export interface PromisifyAllOptions extends PromisifyOptions {
    suffix?: string;
    filter?: (name: string, func: Function, target?: any, passesDefaultFilter?: boolean) => boolean;
    // The promisifier gets a reference to the original method and should return a function which returns a promise
    promisifier?: (originalMethod: Function) => () => Thenable<any>;
  }

  /**
   * Represents an error is an explicit promise rejection as opposed to a thrown error.
   *  For example, if an error is errbacked by a callback API promisified through undefined or undefined
   *  and is not a typed error, it will be converted to a `OperationalError` which has the original error in
   *  the `.cause` property.
   *
   * `OperationalError`s are caught in `.error` handlers.
   */
  export class OperationalError extends Error { }

  /**
   * Signals that an operation has timed out. Used as a custom cancellation reason in `.timeout`.
   */
  export class TimeoutError extends Error { }

  /**
   * Signals that an operation has been aborted or cancelled. The default reason used by `.cancel`.
   */
  export class CancellationError extends Error {}

  /**
   * A collection of errors. `AggregateError` is an array-like object, with numeric indices and a `.length` property.
   *  It supports all generic array methods such as `.forEach` directly.
   *
   * `AggregateError`s are caught in `.error` handlers, even if the contained errors are not operational.
   *
   * `Promise.some` and `Promise.any` use `AggregateError` as rejection reason when they fail.
   */
  export class AggregateError extends Error {}

  /**
   * returned by `Bluebird.disposer()`.
   */
  export class Disposer<R> {
  }

  export interface Thenable<R> {
    then<U>(onFulfilled: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
    then<U>(onFulfilled: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void | Thenable<void>): Thenable<U>;
  }

  export interface Resolver<R> {
    /**
     * Returns a reference to the controlled promise that can be passed to clients.
     */
    promise: Bluebird<R>;

    /**
     * Resolve the underlying promise with `value` as the resolution value. If `value` is a thenable or a promise, the underlying promise will assume its state.
     */
    resolve(value: R): void;
    resolve(): void;

    /**
     * Reject the underlying promise with `reason` as the rejection reason.
     */
    reject(reason: any): void;

    /**
     * Gives you a callback representation of the `PromiseResolver`. Note that this is not a method but a property. The callback accepts error object in first argument and success values on the 2nd parameter and the rest, I.E. node js conventions.
     *
     * If the the callback is called with multiple success values, the resolver fullfills its promise with an array of the values.
     */
    // TODO specify resolver callback
    callback: (err: any, value: R, ...values: R[]) => void;
  }

  export interface Inspection<R> {
    /**
     * See if the underlying promise was fulfilled at the creation time of this inspection object.
     */
    isFulfilled(): boolean;

    /**
     * See if the underlying promise was rejected at the creation time of this inspection object.
     */
    isRejected(): boolean;

    /**
     * See if the underlying promise was defer at the creation time of this inspection object.
     */
    isPending(): boolean;

    /**
     * Get the fulfillment value of the underlying promise. Throws if the promise wasn't fulfilled at the creation time of this inspection object.
     *
     * throws `TypeError`
     */
    value(): R;

    /**
     * Get the rejection reason for the underlying promise. Throws if the promise wasn't rejected at the creation time of this inspection object.
     *
     * throws `TypeError`
     */
    reason(): any;
  }

  /**
   * Changes how bluebird schedules calls a-synchronously.
   *
   * @param scheduler Should be a function that asynchronously schedules
   *                  the calling of the passed in function
   */
  export function setScheduler(scheduler: (callback: (...args: any[]) => void) => void): void;
}

export = Bluebird;
}

// Generated by typings
// Source: node_modules/sp-request/lib/src/core/ISPRequest.d.ts
declare module '~sp-request/lib/src/core/ISPRequest' {
import { OptionsWithUrl, CoreOptions } from '~sp-request~request';
import { IncomingMessage } from 'http';
import '~sp-request/lib/src/core/IncomingMessageWithBody';
import * as Promise from '~sp-request~bluebird';
export interface ISPRequest {
    (opts: OptionsWithUrl): Promise<IncomingMessage>;
    (url: string): Promise<IncomingMessage>;
    (url: string, opts: CoreOptions): Promise<IncomingMessage>;
    get(opts: OptionsWithUrl): Promise<IncomingMessage>;
    get(url: string): Promise<IncomingMessage>;
    get(url: string, opts: CoreOptions): Promise<IncomingMessage>;
    post(opts: OptionsWithUrl): Promise<IncomingMessage>;
    post(url: string): Promise<IncomingMessage>;
    post(url: string, opts: CoreOptions): Promise<IncomingMessage>;
    requestDigest(url: string): Promise<string>;
}
}
declare module 'sp-request/lib/src/core/ISPRequest' {
export * from '~sp-request/lib/src/core/ISPRequest';
}

// Generated by typings
// Source: node_modules/sp-request/lib/src/index.d.ts
declare module '~sp-request/lib/src/index' {
export * from '~sp-request/lib/src/core/SPRequest';
export * from '~sp-request/lib/src/core/auth/IEnvironment';
export * from '~sp-request/lib/src/core/auth/IUserCredentials';
export * from '~sp-request/lib/src/core/ISPRequest';
}
declare module 'sp-request/lib/src/index' {
export * from '~sp-request/lib/src/index';
}
declare module 'sp-request' {
export * from '~sp-request/lib/src/index';
}
